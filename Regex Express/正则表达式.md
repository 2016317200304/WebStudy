# 正则表达式

- 正则表达式是一种用来描述一定数量文本的模式
- 正则表达式引擎是一种可以处理正则表达式的软件

## 文字符号

- 有11个字符被保留作特殊用途

[]/^$.|?*+()

如果想在正则表达式中将这些字符用作文本字符，需要用反斜杠 **/** 进行转码(escape)

例如匹配 1+1=2 用如下正则表达式

```regex
<<1/+1=2>>
```

要注意**在编程语言中要注意，一些特殊的字符会被编译器处理，然后再传递给正则引擎，因此正则表达式<<1/+1=2>>在C++中要写成 "1//+1=2"，为了匹配 "C:/temp"，要用<<C://temp>>，而在C++中正则表达式变成了 "C:temp"**

- 不可显示字符

<</t>>  Tab(0x09)
<</r>>  回车(0x0D)
<</n>>  换行(0x0A)

要注意**Windows中文本文件使用 "/r/n"来结束一行，而Unix用"/n"**

## 正则表达式引擎的内部工作机制

有*文本导向(text-directed)*的引擎和*正则导向(regex-directed)*的引擎，分别称作*DFA*和*NFA*，因为一些很有用的特性，例如"惰性"量词和反向引用，只能在正则导向的引擎中实现，所以这种引擎是目前最流行的引擎

**正则导向的引擎总是返回最左边的匹配**，即使以后有可能发现一个“更好”的匹配，正则导向的引擎也总是返回最左边的匹配，而不会继续查找是否有其他更好的匹配(除非正则表达式要求了)，*因为正则导向的引擎会急于报告它找到的第一个匹配*

## 特殊字符使用

### 字符集

字符集是由一对方括号'[]'括起来的字符集合，使用字符集意思是告诉正则表达式引擎仅仅匹配多个字符中的一个，*字符集中的字符顺序并没有关系，结果都是相同的*

*可以使用连字符'-'定义一个字符范围作为字符集*，例如<<[0-9]>>匹配0到9中的单个数字，还可以使用不止一个范围，如<<[0-9a-zA-Z]>>

```regex
查找一个有可能拼错的单词    <<sep[ae]r[ad]te>>  <<li[cs]en[cs]e>>

查找程序语言的标识符    <<A-Za-z_[A-Za-z0-9]*>> (*表示重复0次或多次)

查找C风格十六进制数     <<0[xX][A-Fa-f0-9]+>>

```

**在左括号后紧跟尖括号"^"，将会对字符集取反**，结果是匹配任何不在方括号中的字符，*不详'.'，取反字符集是可以匹配回车换行符的*

```regex
<<q[^u]>>   意思不是q后面不跟u，而是q后面跟一个不是u的字符(包括回车换行空格)
```

**字符集中只有4个具有特殊意义的字符，它们是 “] / ^ -”，“]” 代表字符集定义的结束；“/” 代表转义；“^” 代表取反；“-” 代表定义范围**，*其他常见的元字符在字符集定义内部都是正常字符，不需要转义*，例如要搜索星号*和加号+，可以用<<[+*]>>，表达式可以很好地工作，但是会降低可读性，因为平时都会转义这些字符

字符集中要将“/”作为一个文本字符来使用时需要进行转义，<<[//x]>>意思时匹配一个 / 或“x”

**“]^-”都可以用反斜杠进行转义，或者将它们放在一个不能使用它们特殊含义的位置**推荐使用后者，因为可以增加可读性
*比如 “^”，只要不是紧跟放在左方括号后，使用它都是文字字符含义而不是取反*<<[m^]>>匹配一个 m 或者 ^
*比如 “]”，紧跟着左方括号就只是文本字符意思*
<<[]x]>>匹配一个 ] 或 x

<<[-x]>>或<<[x-]>>都是匹配一个 - 或一个 x

#### 字符集简写

以下字符集随正则表达式的实现不同有关，但是绝大多数的正则表达式实现的字符集都是这样

<</d>>代表<<[0-9]>>
<</w>>代表<<[A-Za-z]>>
<</s>>代表空白字符，绝大多数实现中包括空格、tab符、回车和换行符

字符集缩写形式可以写在方括号里面和外面

取反字符集缩写

<<[/S]>>    <<[^/s]>>
<<[/W]>>    <<[^/w]>>
<<[/D]>>    <<[^/d]>>

**如果用 * + ? 来重复一个字符集，将会重复整个字符集，如<<[0-9]+>>可以匹配234以及333**，如果只想重复匹配到的那个字符，可以用向后引用

### 使用?*+进行重复

- ?:告诉引擎匹配前导字符0次或1次，即可选 {0,1}
- +:告诉引擎匹配前导字符1次或多次 {1,}
- *:告诉引擎匹配前导字符0次或多次 {0,}

**限制性重复**{min, max}，允许定义一个字符重复了多少次，min和max都是非负整数，如果有逗号没有max则没有上限，没有下限同理，如果只有一个数字那就是固定重复次数

<</b[1-9][0-9]{3}/b>> 1000到9999的数字
**/b**是单词边界

**“+”是贪婪的**，+ 会导致正则表达式引擎试图尽可能地重复前导字符，直到这种重复会引起整个正则表达式匹配失败的情况下，引擎会进行回溯，**“?”**的重复也是贪婪的，例如匹配一个HTML标签

```regex
<< <.+> >>
在This is a <EM>first</EM>中进行匹配，期望返回<EM>，但是会返回<EM>first</EM>
```

#### 深入正则表达式引擎内部工作过程

上面例子的正则引擎匹配过程为：
*第一个记号是‘<’，这是一个文字符号，第二个记号是‘.’，匹配到的是‘E’，然后‘+’一直可以匹配其余字符，直到换行('.'不能匹配换行)，引擎开始对下一个正则表达式符号开始匹配，即‘>’，到目前为止，“<.+”已经匹配了 ```<EM>first</EM>test```，引擎试图将‘>’与换行进行匹配，匹配失败，于是引擎进行回溯，现在是“<.+”匹配了```<EM>first</EM>tes```，引擎试图将‘>’与‘t’进行匹配，失败，继续回溯，直到“<.+”匹配 ```<EM>first</EM```，引擎将 `>`与‘>’匹配，成功，得到一个成功的匹配*

所以，由于 + 的贪婪性，匹配得到了最左边最长的字符串

用**懒惰性**取代**贪婪性**，在‘+’后紧跟一个‘?’来达到目的，过程如下:

更好的，可以*用一个贪婪重复与一个取反字符集* << <[^>]+> >>，之所以更好是因为懒惰性重复时引擎会在成功匹配前对每一个字符进行回溯

以上是对正则导向的引擎，*文本导向的引擎是不回溯的，同时也不支持懒惰性重复操作*

### 使用 . 匹配几乎任意字符

. 匹配一个单个的字符，除了新行，即<<[^/n/r]>>(Windows) <<[^/n]>>(Unix)

这个例外是由于历史原因，早期使用的正则表达式工具是基于行的，它们一行一行读入一个文件，将正则表达式风别应用到每一行，在这些工具中字符串不包括换行

### 字符串开始和结束的锚定

锚定和一般的正则表达式符号不同，**它不匹配任何字符**相反它们匹配的是字符前或者字符后的位置
**“^”匹配一行字符串第一个字符前的位置**
**“$”匹配一行字符串最后一个字符后的位置**

